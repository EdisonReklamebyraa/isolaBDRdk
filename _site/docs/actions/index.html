<h1 id="actions">Actions</h1>

<p>Each action returned by <a href="createActions.md"><code>alt.createActions</code></a> comes with a few different properties.</p>

<h2 id="action">action</h2>

<blockquote>
  <p>(…data: mixed): mixed</p>
</blockquote>

<p>The action itself is a reference to the function that handles the action. The actions are fire and forget like in flux. One solution to know when an action has completed is to return a promise from the action so these calls can later be aggregated. This is a convenient approach if you’re attempting to use actions on the server so you can be notified when all actions have completed and it is safe to render.</p>

<p><code>js
MyActions.updateName('Zack');
</code></p>

<h2 id="actiondefer">action.defer</h2>

<blockquote>
  <p>(data: mixed): undefined</p>
</blockquote>

<p>This is a method that faciliates calling multiple actions in another actions. Since multiple actions cannot be fired until the dispatch loop has finished this helper function waits for the dispatch loop to finish and then fires off the action. It is not recommended but it is available anyway.</p>

<p><code>js
MyActions.updateName.defer('Zack');
</code></p>

<h2 id="actionconstant">action.CONSTANT</h2>

<p>A constant is automatically available at creation time. This is a unique identifier for the constant that can be used for dispatching and listening.</p>

<p><code>js
MyActions.prototype.updateName = function (name) { };
</code></p>

<p>will become</p>

<p><code>js
myActions.UPDATE_NAME;
</code></p>

<h2 id="actionmethodname">action.methodName</h2>

<p>Similar to the constant.</p>

<p><code>js
MyActions.prototype.updateName = function (name) { };
</code></p>

<p>is</p>

<p><code>js
myActions.updateName;
</code></p>

<p>This allows flexibility giving you choice between using the constant form or the method form.</p>
